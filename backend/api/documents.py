from typing import Any, Dict, Optional

from fastapi import APIRouter, Depends, HTTPException, status
from pydantic import BaseModel, Field

from auth import get_current_user
from services.qdrant_service import QdrantService

router = APIRouter(prefix="/api/documents", tags=["documents"])

qdrant_service = QdrantService()


class DocumentRequest(BaseModel):
    content: str = Field(..., description="Raw text content to embed and store")
    metadata: Optional[Dict[str, Any]] = Field(
        default=None,
        description="Optional metadata payload stored alongside the document",
    )
    document_id: Optional[str] = Field(
        default=None,
        description="Optional custom ID for the document; autogenerated if missing",
    )
    collection: Optional[str] = Field(
        default=None,
        description="Optional Qdrant collection name; defaults to 'documents'",
    )


class DocumentResponse(BaseModel):
    id: str
    collection: str


@router.post(
    "/",
    response_model=DocumentResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Embed and store a document in Qdrant",
)
async def upsert_document(
    request: DocumentRequest,
    current_user: dict = Depends(get_current_user),
):
    """
    Embed the provided content using OpenAI and upsert into Qdrant.
    Requires a valid authenticated user to prevent anonymous writes.
    """
    try:
        result = qdrant_service.upsert_document(
            content=request.content,
            metadata=request.metadata,
            document_id=request.document_id,
            collection_name=request.collection,
            user_id=current_user["id"],
        )
        return DocumentResponse(**result)
    except ValueError as ve:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(ve),
        ) from ve
    except Exception as exc:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to store document: {exc}",
        ) from exc


class DocumentSearchRequest(BaseModel):
    query: str = Field(..., description="Search query text")
    top_k: int = Field(default=5, ge=1, le=20, description="Number of results to return")
    collection: Optional[str] = Field(
        default=None,
        description="Optional Qdrant collection name; defaults to 'documents'",
    )
    score_threshold: Optional[float] = Field(
        default=None,
        ge=0.0,
        le=1.0,
        description="Optional score threshold for matches",
    )


@router.post(
    "/search",
    status_code=status.HTTP_200_OK,
    summary="Search documents in Qdrant for the current user",
)
async def search_documents(
    request: DocumentSearchRequest,
    current_user: dict = Depends(get_current_user),
):
    """Return the most relevant documents for a user's query."""
    try:
        matches = qdrant_service.search(
            query=request.query,
            user_id=current_user["id"],
            collection_name=request.collection,
            top_k=request.top_k,
            score_threshold=request.score_threshold,
        )
        return {"results": matches}
    except ValueError as ve:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(ve),
        ) from ve
    except Exception as exc:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to search documents: {exc}",
        ) from exc
